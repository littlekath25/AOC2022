package aoc21
import scala.io.Source

sealed trait Monkey
case class NumberMonkey(name: String, number: Long) extends Monkey
case class MathMonkey(name: String, neighMonkey1: String, neighMonkey2: String, mathOp: Char) extends Monkey
case class SpecialMonkey(name: String, neighMonkey1: String, neighMonkey2: String, number: Long) extends Monkey

def lookForNumberMonkeys(nm: String, allMonkeys: List[Monkey]): Option[NumberMonkey] =
  allMonkeys match {
    case h :: t => h match {
      case n: NumberMonkey if (n.name == nm) => Some(n)
      case _                                 => lookForNumberMonkeys(nm, t)
    }
    case Nil                                 => None
  }

def doMath(operation: Char, first: Long, second: Long): Long =
  operation match {
    case ('+') => first + second
    case ('-') => first - second
    case ('*') => first * second
    case ('/') => first / second
  }

def updateMonkey(mathMonkey: MathMonkey, allMonkeys: List[Monkey]): Monkey =
  val nm1 = mathMonkey.neighMonkey1
  val nm2 = mathMonkey.neighMonkey2
  val opNeighMonkey1 = lookForNumberMonkeys(nm1, allMonkeys)
  val opNeighMonkey2 = lookForNumberMonkeys(nm2, allMonkeys)
  if (opNeighMonkey1.isDefined && opNeighMonkey2.isDefined) {
    val nm = NumberMonkey(mathMonkey.name, doMath(mathMonkey.mathOp, opNeighMonkey1.get.number, opNeighMonkey2.get.number))
    nm
  } else {
    mathMonkey
  }

def reverseAllTheMonkeys(allMonkeys: List[Monkey]): List[Monkey] =
  val iDontKnow2 =
    allMonkeys.drop(1).map { monkey =>
      monkey match {
        case mm: MathMonkey => convertMonkey(allMonkeys, mm.name)
        case sm: SpecialMonkey => convertMonkey(allMonkeys, sm.name) // dez
        case nm: NumberMonkey => nm
      }
    }
  iDontKnow2

def convertMonkey(allMonkeys: List[Monkey], startMonkey: String): Monkey =
  val getCurrentMonkey = findMonkeyInList(allMonkeys, startMonkey)

  getCurrentMonkey match
    case mm: MathMonkey if (mm.neighMonkey1 == startMonkey) => MathMonkey(startMonkey, mm.name, mm.neighMonkey2, reverseOp(mm.mathOp))
    case mm: MathMonkey if (mm.neighMonkey2 == startMonkey) => MathMonkey(startMonkey, mm.name, mm.neighMonkey1, reverseOp(mm.mathOp))
    case nm: NumberMonkey => nm
    case sm: SpecialMonkey => sm
    case _ => sys.error("booboo")

def reverseOp(op: Char): Char =
  op match {
    case '+' => '-'
    case '-' => '+'
    case '*' => '/'
    case '/' => '*'
  }

def getCorrectBranch(allMonkeys: List[Monkey], goalNeigh1: String, goalNeigh2: String): (NumberMonkey, List[Monkey]) =
  if (lookForNumberMonkeys(goalNeigh1, allMonkeys).isDefined || lookForNumberMonkeys(goalNeigh2, allMonkeys).isDefined)
    {(List(lookForNumberMonkeys(goalNeigh1, allMonkeys), lookForNumberMonkeys(goalNeigh2, allMonkeys)).flatten.head, allMonkeys)
  } else {
    val newMonkeys = allMonkeys.scanLeft(allMonkeys)((updatedMonkeys, m) => m match {
      case m: MathMonkey => {
        val index = updatedMonkeys.indexOf(m)
        updatedMonkeys.updated(index, updateMonkey(m, updatedMonkeys))
      }
      case _ => updatedMonkeys
    })
    getCorrectBranch(newMonkeys.last, goalNeigh1: String, goalNeigh2: String)
  }

def findMonkeyInList(allMonkeys: List[Monkey], name: String): Monkey =
  allMonkeys match {
    case head :: next => head match {
      case mm: MathMonkey if (mm.name == name) => mm
      case nm: NumberMonkey if(nm.name == name) => nm
      case sm: SpecialMonkey => sm
      case _ => findMonkeyInList(next, name)
    }
  }

def goOverMonkeysPart2(allMonkeys: List[Monkey]): List[Monkey] =
  if (allMonkeys.collect{case n: NumberMonkey => n}.size == allMonkeys.size)
    allMonkeys
  else
    val newConvertedList = allMonkeys.map { monkey => 
      monkey match
        case mm: MathMonkey =>
          updateMonkey(mm, allMonkeys)

        case nm: NumberMonkey => 
          nm

        case sm: SpecialMonkey =>
          sm
      }
    goOverMonkeysPart2(newConvertedList)
  
// def goOverMonkeys(allMonkeys: List[Monkey], goal: String = "humn"): NumberMonkey =
//   if (lookForNumberMonkeys(goal, allMonkeys).isDefined)
//     lookForNumberMonkeys(goal, allMonkeys).get
//   else
//     val newMonkeys = allMonkeys.scanLeft(allMonkeys)((updatedMonkeys, m) => m match {
//       case m: MathMonkey => {
//         val index = updatedMonkeys.indexOf(m)
//         updatedMonkeys.updated(index, updateMonkey(m, updatedMonkeys))
//       }
//       case _ => updatedMonkeys
//     })
//     goOverMonkeys(newMonkeys.last)

object AOC21 extends App:
//  val input = Source.fromResource("Day21.txt")
//    .getLines
//    .map{l => l match {
//      case s"$name: $monkeyName1 + $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '+')
//      case s"$name: $monkeyName1 - $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '-')
//      case s"$name: $monkeyName1 / $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '/')
//      case s"$name: $monkeyName1 * $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '*')
//      case s"$name: $number"                     => NumberMonkey(name, number.toLong)
//    }}
//    .toList

  val inputP2 = Source.fromResource("Day21.txt")
    .getLines
    .map{l => l match {
      case s"root: $monkeyName1 + $monkeyName2"  => SpecialMonkey("root", monkeyName1, monkeyName2, 23440423968672L)
      case s"humn: $number"                      => MathMonkey("humn", "unknown", "unknown", '+')
      case s"$name: $monkeyName1 + $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '+')
      case s"$name: $monkeyName1 - $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '-')
      case s"$name: $monkeyName1 / $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '/')
      case s"$name: $monkeyName1 * $monkeyName2" => MathMonkey(name, monkeyName1, monkeyName2, '*')
      case s"$name: $number"                     => NumberMonkey(name, number.toLong)
    }}
    .toList

  val specialMonkey = inputP2.collect{case s: SpecialMonkey => s}.head
  val indexRoot     = inputP2.indexOf(specialMonkey)

  val correctBranch = getCorrectBranch(inputP2, specialMonkey.neighMonkey1, specialMonkey.neighMonkey2)
  val newInputP2 = correctBranch._2.updated(indexRoot, specialMonkey.copy(number = correctBranch._1.number))

  val reversedList = reverseAllTheMonkeys(inputP2).distinct
  val convertedToNumberMonkeys = goOverMonkeysPart2(reversedList)

  // println(s"THE CORRECT BRANCH: ${correctBranch._1}")
  // println(reversedList)
  // println(s"NEW: ${convertedToNumberMonkeys}")